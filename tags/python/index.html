<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>/home/yorodm/tags/python/</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="all,follow">
    <meta name="googlebot" content="index,follow,snippet,archive">
    <link rel="stylesheet" href="https://yorodm.github.io/hugo-theme-console/css/terminal-0.7.1.min.css">
    <link rel="stylesheet" href="https://yorodm.github.io/hugo-theme-console/css/animate-3.7.2.min.css">
    <link rel="stylesheet" href="https://yorodm.github.io/hugo-theme-console/css/console.css">
    
      <!--[if lt IE 9]>
          <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
          <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
      <![endif]-->
       
      <link href="https://yorodm.github.io/tags/python/index.xml" rel="alternate" type="application/rss+xml" title="/home/yorodm" />
    <meta property="og:title" content="python" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://yorodm.github.io/tags/python/" />


<meta name="twitter:title" content="python"/>
<meta name="twitter:description" content=""/>

<link rel="stylesheet" href="https://yorodm.github.io/css/syntax.css">
<link rel="stylesheet" href="https://yorodm.github.io/css/site.css">
<link rel="alternate" type="application/rss+xml" href="https://yorodm.github.io/tags/python/index.xml" title="/home/yorodm" />
</head>
<body class="terminal">
    <div class="container">
        <div class="terminal-nav">
          <header class="terminal-logo">
            <div class="logo terminal-prompt">
              
              
              <a href="https://yorodm.github.io/" class="no-style ">/home/yorodm</a>:~# 
              <a href='https://yorodm.github.io/tags'>tags</a>/<a href='https://yorodm.github.io/tags/python'>python</a>/</div></header>
          <nav class="terminal-menu">
            <ul vocab="https://schema.org/" typeof="BreadcrumbList">
                
                <li><a href="https://yorodm.github.io/about/" typeof="ListItem">about/</a></li>
                
                <li><a href="https://yorodm.github.io/blog/" typeof="ListItem">blog/</a></li>
                
                <li><a href="https://yorodm.github.io/series/" typeof="ListItem">series/</a></li>
                
            </ul>
          </nav>
        </div>
    </div>

    <div class="container animated zoomIn fast">
        
<h1>python</h1>
<br/>


<div class="posts-list">

    
        <div class="post">
            <div class="date">Nov. 4, 2019</div>    
            <h1><a href="https://yorodm.github.io/blog/python-work-queue/" title="Cola de tareas en Python (I)">Cola de tareas en Python (I)</a></h1>
            Después de unos meses trabajando en Go se llegan a extrañar las abstracciones del lenguaje para concurrencia. Hoy por ejemplo necesitaba hacer una cola de tareas en Python utilizando AsyncIO. En Go esto sigue una estructura sencilla:
// Este es la gorutina que procesa los trabajos func worker(jobChan &lt;-chan Job) { for job := range jobChan { process(job) } } // Creamos un canal a donde enviar los datos jobChan := make(chan Job, 10) // Arrancamos la gorutina go worker(jobChan) // Enviamos datos para un trabajo, esto puede ser desde cualquier // gorutina jobChan &lt;- job //Indicamos que ya no vamos a procesar más datos close(jobChan) Veamos si podemos lograr un equivalente en Python:
        </div>
    

    
        <div class="post">
            <div class="date">Mar. 12, 2019</div>    
            <h1><a href="https://yorodm.github.io/blog/plumber-simple-etl/" title="Plumber: ETL simple para Python">Plumber: ETL simple para Python</a></h1>
            Implementando una feature para uno de los proyectos en los que trabajo terminé necesitando hacer el típico proceso ETL que tomara las cosas de una fuente X, las pasara por 1 o varios filtros y las cargara en nuestra base de datos documental.
Ahora, si bien existen frameworks de excelente calidad como petl y Bonobo que cubren este campo, me encontré con los siguientes problemas:
 Existe mucho código legacy en el proyecto.
        </div>
    

    
        <div class="post">
            <div class="date">Jan. 15, 2019</div>    
            <h1><a href="https://yorodm.github.io/blog/decoradores-stdlib/" title="Python: Decoradores estándar y su uso">Python: Decoradores estándar y su uso</a></h1>
            Entre las baterías includas de Python, vienen varios decoradores que nos facilitan la vida. Aquí una lista de algunos y breve explicación acerca de su uso.
Decoradores para OOP property Uno de los más usados. Convierte un conjunto de métodos en un descriptor que hace las funciones de propiedad. Útil cuando queremos adicionar algún tipo de lógica a propiedades de la clase.
class C: def __init__(self): self._x = None def getx(self): return self.
        </div>
    

    
        <div class="post">
            <div class="date">Oct. 29, 2018</div>    
            <h1><a href="https://yorodm.github.io/blog/python-simple-cli/" title="Interfaces de comandos con Python">Interfaces de comandos con Python</a></h1>
            Interfaces de comandos sencillas con Python. Entre las muchas cosas para las que uso Python está escribir pequeñas herramientas de líneas de comandos que me ayudan en el día a día (especialmente cuando toca trabajar de devops). Aunque en la biblioteca estándar existe argparse y muchos están contentos con eso, personalmente me gustan alternativas que me hagan la vida más fácil.
Docopt. Docopt Es (en mi opinión) uno de los mejores frameworks para crear herramientas de líneas de comandos que existe y tiene además la ventaja de no ser exclusiva de Python, para utilizarla solo tienes que documentar el módulo o función que va a obtener los argumentos de la línea de comandos.
        </div>
    

    
        <div class="post">
            <div class="date">Dec. 15, 2017</div>    
            <h1><a href="https://yorodm.github.io/blog/generadores-referencias-python/" title="Generadores y referencias">Generadores y referencias</a></h1>
            Generadores y referencias Las referencias en Python son un tema que a menudo se pasa por alto, incluso por los que ya no somos tan novatos. Hagamos un experimento, toma a diez desarrolladores que conozcas y pregúntales qué hay de malo en esta función.
def funcionx(*args): ctx = dict() for x in args: ctx[&#39;run&#39;] = x yield ctx Vale, es una pregunta con truco y la respuesta es todo o nada en dependencia de como utilices la función generadora.
        </div>
    

    
        <div class="post">
            <div class="date">Dec. 13, 2017</div>    
            <h1><a href="https://yorodm.github.io/blog/pruebas-funcionales-factory-boy/" title="Pruebas funcionales con factory_boy y faker">Pruebas funcionales con factory_boy y faker</a></h1>
            Pruebas funcionales con factory_boy. Una de las primeras cosas que aprendí cuando comencé a hacer pruebas funcionales (allá en los lejanos tiempos de la universidad) fue la necesidad de crear juegos de datos con el mayor nivel de realidad posible. En ese entonces era práctica común entre compañeros de equipo guardar un archivo CSV con nuestra información personal (nombre, número de identidad, etc) e incluso hubo alguna que otra base de datos llena de información ficticia creada por los más minuciosos.
        </div>
    

    
        <div class="post">
            <div class="date">Nov. 9, 2017</div>    
            <h1><a href="https://yorodm.github.io/blog/nameko-microservicios-python/" title="Desarrollando microservicios con Nameko">Desarrollando microservicios con Nameko</a></h1>
            Desarrollando microservicios con Nameko Nameko es una biblioteca para el desarrollo de microservicios en Python. A diferencia de otros frameworks como Django, Flask y Hug que tienen como principal objetivo utilizar HTTP para la comunicación con los clientes, Nameko viene con soporte integrado para AMQP y Websockets y nos permite adicionar nuestros propios protocolos.
Manos a la obra. Para hacer servicios con Nameko necesitamos algunas cosas:
 Python 2 (creo que no hay versiones para Python 3).
        </div>
    

</div>


        <div class="footer">
  Powered by <a href="https://gohugo.io/">Hugo</a> and Emacs(❤)
  
  // <a href="http://twitter.com/yorodm">Twitter</a>
  
  // <a href="http://github.com/yorodm">GitHub</a>
  
</div>

    </div>
  </body>
</html>
